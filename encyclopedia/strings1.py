# ============================  Строки =====================================
'''
Строки являются упорядоченными последовательностями символов.
Длина строки ограничена лишь объемом оперативной памяти компьютера.
Как и все последовательности, строки поддерживают:
- обращение к элементу по индексу,
- получение среза,
- конкатенацию (оператор+),
- повторение (оператор*),
- проверку на вхождение (оператор in).
Кроме того, строки относятся к неизменяемым тиnам данных.
Поэтому практически все строковые методы в качестве значения возвращают новую строку.
При использовании небольших строк это не приводит к каким-либо проблемам,
но nри работе с большими строками можно столкнуться с nроблемой нехватки памяти.
Иными словами, можно получить символ по индексу, но изменить его нельзя (листинг 6.1 ).
'''
s = "Python"
print(s[0])                                     # Можно nолучить символ no индексу
# 'Р'
# s[0] = "J"                                    # Изменить строку нельзя
#Traceback (most recent call last):
#  File "<pyshell#32>", line 1, in <module>
#    s[0] = "J"
#TypeError: 'str' object does not support item assignment

# В некоторых языках программирования концом строки является нулевой символ. 
# В языке Pythoп нулевой символ может быть расположен внутри строки:
"string\x00string"                # Нулевой символ - это НЕ конец строки
# 'string\x00string'

# Язык Python 3 поддерживает следующие строковые типы:

# str - Unicode-cтpoкa без привязки к конкретной кодировке (UTF-8, UTF-16 или UTF-32).
#       Такие строки следует рассматривать как строки в некой абстрактной кодировке,
#       позволяющие хранить символы Unicode и производить маниnуляции с ними.
#       При выводе Unicode-cтpoкy необходимо преобразовать в последовательность
#       байтов в какой-либо кодировке:
type("строка")
# <class 'str'> 
"строка".encode(encoding="cp1251")
# b'\xf1\xf2\xf0\xee\xea\xe0'
"строка".encode(encoding="utf-8")
# b'\xd1\x81\xd1\x82\xd1\x80\xd0\xbe\xdO\xba\xdO\xЬO'

# bytes - неизменяемая последовательность байтов. Каждый элемент последовательности
#         может хранить целое число от о до 255, которое обозначает код символа.
#         Объект типа bytes поддерживает большинство строковых методов и, если это возможно,
#         выводится как последовательность символов.
#         Однако доступ по индексу возвращает целое число, а не символ. Пример:
s = bytes("стр str", "cp1251")
s[0], s[5], s[0:3], s[4:7]
# (241, 116, b'\xf1\xf2\xf0', b'str')
s
# b'\xf1\xf2\xf0 str'
# Объект типа bytes может содержать как однобайтовые символы, так и многобайтовые.
# ВНИМАНИЕ! Функции и методы строк некорректно работают с многобайтовыми
#           кодировками, например, функция len() вернет количество байтов, а не символов:
len("строка")
# 6
len(bytes("строка", "cp1251"))
# 6
len(bytes("строка", "utf-8"))
# 12

# bytearray - изменяемая последовательность байтов. Тип bytearray аналогичен типу
#             bytes, но позволяет изменять элементы по индексу и содержит доnолнительные методы,
#             позволяющие добавлять и удалять элементы. Пример:
s = bytearray("str", "cp1251")
s[0] = 49; print(s)         # Можно изменить символ. Символ с индексом 0 меняем с s на цифру 1.
# bytearray(b'ltr')
s.append(55); print(s)      # Можно добавить символ. Добавляем цифру 7 в конец bytearray
# bytearray(b'ltr7')

# Тип str следует использовать для хранения текстовых данных. Именно этот тип называется словом "строка".
# Типы bytes и bytearray следует используются для хранения бинарных данных, например, изображений,
# а также для промежуточного хранения текстовых данных.

# ============================ Создание строки ===================================
# Создать строку можно следующими способами:

# - с помощью функции str([<Объект>[, <Кодировка>[, <Обработка ошибок>]]]).

#   Если указан только первый параметр, то функция возвращает строковое представление любого объекта.
#   Если параметры не указаны вообще, то возвращается пустая строка. Пример:
str(), str([1, 2]), str((3, 4)), str({"x": 1})
# ('', '[1, 2]', '(3, 4)', "{'х': 1}")
str(b"\xf1\xf2\xf0\xee\xea\xe0")
# "b'\\xf1\\xf2\\xf0\\xee\\xea\\xe0'"

# Особенность преобразования объекта типа bytes в строку.
# Мы получили строковое представление объекта, а не нормальную строку.
# Чтобы получить именно строку из объектов типа bytes и bytearray, следует указать
# кодировку во втором параметре:
str(b"\xf1\xf2\xf0\xee\xea\xe0", "cp1251")
# 'строка'
'''
В третьем параметре могут быть указаны значения:
- "strict" (при ошибке возбуждается исключение UnicodeDecodeError; значение по умолчанию),
- "replace" (неизвестный символ заменяется символом, имеющим код \uFFFD) или
- "ignore" (неизвестные символы игнорируются):
'''
obj1 = bytes("строка1", "utf-8")
obj2 = bytearray("cтpoкa2", "utf-8")
str(obj1, "utf-8"), str(obj2, "utf-8")
# ('строка1', 'строка2')

# str(obj1, "ascii", "strict")
# Traceback (most recent call last):
#   File "<pyshel1#16>", 1ine 1, in <modu1e>
#       str(obj1, "ascii", "strict")
# UnicodeDecodeError: 'ascii' codec can't decode byte 0xd1 in position 0: ordinal not in range(128)

str(obj1, "ascii", "ignore")
# '1'

# - указав строку между апострофами или двойными кавычками:

'строка', "строка", '"х": 5', "'х': 5"
# ('строка', 'строка', '"х": 5', "'х': 5")
print('Cтpoкa1\nCтpoкa2')
# Строка1
# Строка2
print("Cтpoкa1\nCтpoкa2")
# Строка1
# Строка2
'''
В РНР строка в апострофах отличается от строки в кавычках тем, что внутри апострофов
специальные символы выводятся как есть, а внутри кавычек спецсимволы интерпретируются.
В языке Python никакого отличия между строкой в апострофах и строкой в кавычках нет.
Все специальные символы в таких строках интерпретируются.
Например, последовательность символов \n преобразуется в символ новой строки.
Чтобы специальный символ выводился как есть, его необходимо экранировать с nомощью слэша:
'''
print("Cтpoкa1\\nCтpoкa2")
# Строка1\nСтрока2
print('Cтpoкa1\\nCтpoкa2')
# Строка1\nСтрока2

# Кавычку, внутри строки в кавычках, и апостроф, внутри строки в апострофах, также необходимо
# экранировать с помощью защитного слэша:
"\"х\": 5", '\'х\': 5'
#( '"х": 5', "' х': 5")

# Следует также заметить, что заключить объект в одинарные кавычки (или апострофы) на
# нескольких строках нельзя. Переход на новую строку вызовет синтаксическую ошибку:
#"string
#SyntaxError: EOL while scanning string literal
# Чтобы расnоложить объект на нескольких строках, следует:
# - перед символом перевода строки указать символ \,
# - поместить две строки внутри скобок, 
# - исnользовать конкатенацию внутри скобок:
"stringl \
string2"                # После \ не должно быть никаких символов
# 'stringlstring2'
("stringl"              # неявная конкатенация строк
"string2")
# 'stringlstring2'
("stringl" +            # Явная конкатенация строк
"string2")
# 'stringlstring2'

# Кроме того, если в конце строки расположен символ \,то его необходимо экранировать,
# иначе будет выведено сообщение об ошибке: ·
# print("string\")
# SyntaxError: EOL while scanning string literal
print("string\\")
# string\

# - указав строку между утроенными апострофами или утроенными кавычками.

#   Такие объекты можно разместить на нескольких строках, а также одновременно использовать
#   кавычки и апострофы без необходимости их экранировать.
#   Все специальные символы в таких строках интерпретируются. Примеры:
print('''Строкаl
Строка2''')
# Строкаl
# Строка2
print("""Cтpoкal
Строка2""")
# Строкаl
# Строка2
'''
Если строка не присваивается переменной, то она считается строкой документирования.
Такая строка сохраняется в атрибуте __doc__ того объекта, в котором расположена. 
Пример функции со строкой документирования:
'''
def test():
    """Это описание функции"""
    pass

print(test.__doc__)
# Это описание функции

# Если перед строкой разместить модификатор r, то специальные символы внутри строки
# выводятся как есть. Например, символ \n не будет преобразован в символ перевода строки.
# Иными словами, он будет считаться последовательностью двух символов: \ и n:
print("Cтpoкal\nCтpoкa2")
# Строкаl
# Строка2
print(r"Cтpoкal\nCтpoкa2")
# Строкаl\nСтрока2
print(r"""Строкаl\nСтрока2""")
# Строкаl\nСтрока2

# Такие неформатированные строки удобно использовать в шаблонах регулярных выражений,
# а также при указании пути к файлу или каталогу:
print(r"C:\Python32\lib\site-packages")
# C:\Python32\lib\site-packages

# Если модификатор не указать, то все слэши в пути необходимо экранировать:
print("С:\\Python32\\lib\\site-packages")
# C:\Python32\lib\site-packages

# Если в конце неформатированной строки расположен слэш, то его необходимо экранировать.
# Однако следует учитывать, что этот слэш будет добавлен в исходную строку. Пример:
# print(r"C:\Python32\lib\site-packages\")
# SyntaxError: EOL while scanning string literal
print(r"C:\Python32\lib\site-packages\\")
# C:\Python32\lib\site-pacкages\\
# Чтобы избавиться от лишнего слэша, можно использовать операцию конкатенации строк,
# обычные строки или удалить слэш явным образом:
print(r"C:\Python32\lib\site-packages" + "\\")  #Конкатенация
# C:\Python32\lib\site-packages\
print("C:\\Python32\\lib\\site-packages\\")     #Обычная строка
# C:\Python32\lib\site-packages\
print(r"C:\Python32\lib\site-packages\\"[:-1])  #Удаление слэша
# C:\Python32\lib\site-packages\


# ========================== Специальные символы ====================================

# Специальные символы - это комбинации знаков, обозначающих служебные или непечатаемые
# символы, которые невозможно вставить обычным способом. Перечислим специальные
# символы, допустимые внутри строки, перед которой нет модификатора r:
# \n - перевод строки;
# \r - возврат каретки;
# \t - знак табуляции;
# \v - вертикальная табуляция;
# \а - звонок;
# \b - забой;
# \f - перевод формата;
# \0 - нулевой символ (не является концом строки);
# \" - кавычка;
# \' - апостроф;
# \N - восьмеричное значение N. Например, \74 соответствует символу <;
# \xN - шестнадцатеричное значение N. Например, \хbа соответствует символу j;
# \\  - обратный слэш;
# \uxxxx     - 16-битный символ Uпicode. Например, \u043a соответствует русской букве к;
# \Uxxxxxxxx - 32-битный символ Uпicode.
# Если после слэша не стоит символ, который вместе со слэшем интерпретируется как спецсимвол,
# то слэш сохраняется в составе строки:
print("Этот символ \не специальный")
# Этот символ \не специальный
# Тем не менее, лучше экранировать слэш явным образом:
print("Этот символ \\не специальный")
# Этот символ \не специальный

# ============================= Операции над строками =================================
# Cтроки относятся к последовательностям.
# Как и все последовательности, строки поддерживают:
# - обращение к элементу по индексу,
# - получение среза,
# - конкатенацию,
# - повторение и
# - проверку на вхождение.

# Рассмотрим эти операции подробно.
# К любому символу строки можно обратиться как к элементу списка. Достаточно указать его
# индекс в квадратных скобках. Нумерация начинается с нуля:
s = "Python"
s[0], s[1], s[2], s[3], s[4], s[5]
# ('Р', 'у', 't', 'h', 'о', 'n')

# Если символ, соответствующий указанному индексу, отсутствует в строке, то возбуждается
# исключение IndexError:
s = "Python"
# s[10]
#Traceback (most recent са11 last) :
#    Fi1e "<pyshell#90>", line 1, in <module>
#        s[10]
#IndexError: string index out of range

# В качестве индекса можно указать отрицательное значение.
# В этом случае смещение будет отсчитываться от конца строки, а точнее,
# значение вычитается из длины строки, чтобы nолучить положительный индекс:
s = "Python"
s[-1], s[len(s)-1]
#('n', 'n')

# Так как строки относятся к неюменяемым типам данных, то ИЗМЕНИТЬ СИМВОЛ ПО ИНДЕКСУ НЕЛЬЗЯ:
s = "Python"
# s[0] = "J"                              # ИЗМЕНИТЬ СТРОКУ НЕЛЬЗЯ
# Traceback (most recent саll last) :
#   Fi1e "<pyshell#94>", line 1, in <module>
#       s[0] = "J"                      # Изменить строку нельзя
# TypeError: 'str' object does not support item assignment

# Чтобы выполнить изменение, можно воспользоваться операцией извлечения среза, которая
# возвращает указанный фрагмент строки. Формат операции:
# [<Начало>:<Конец>:<Шаг>]
# Все параметры являются необязательными.
# Если параметр <Начало> не указан, то используется значение 0.
# Если параметр <Конец> не указан, то возвращается фрагмент до конца строки.
# При этом, символ с индексом, указанным в этом параметре, не входит в возвращаемый фрагмент.
# Если параметр <Шаг> не указан, то используется значение 1.
# В качестве значения параметров можно указать отрицательные значения.
# Теперь рассмотрим несколько примеров. Сначала получим копию строки:
s = "Python"
s[:]            #Возвращается фрагмент от позиции 0 до конца строки
# 'Python'
# Теперь выведем символы в обратном порядке:
s[::-1]         #Указываем отрицательное значение в параметре <Шаг>
# 'nohtyP'
# Заменим первый символ в строке:
"J" + s[1:]     #Извлекаем фрагмент от символа 1 до конца строки
# 'Jython'
# Удалим последний символ:
s[:-1]          # Возвращается фрагмент от 0 до len(s)-1
# 'Pytho'
# Получим первый символ в строке:
s[0:1]          #Символ с индексом 1 не входит в диапазон
# 'Р'
# А теnерь nолучим nоследний символ:
s[-1:]          #Получаем фрагмент от len(s)-1 до конца строки
# 'n'
# И, наконец, выведем символы с индексами 2, 3 и 4:
s[2:5]          # Возвращаются символы с индексами 2, 3 и 4
# 'tho'

# Узнать количество символов в строке nозволяет функция len():
len("Python"), len("\r\n\t"), len(r"\r\n\t")
# (6, 3, 6)

# Теnерь, когда мы знаем количество символов, можно перебрать все символы с помощью цикла for:
s = "Python"
for i in range(len(s)): print(s[i], end=" ")
# Результат выполнения:
# Python

# Так как строки поддерживают итерации, мы можем просто указать строку в качестве nараметра цикла:
s = "Python"
for i in s: print(i, end=" ")
# Результат выполнения будет таким же:
# Python

# Соединить две строки в одну строку nозволяет оnератор +:
print("Строка1" + "Строка2")
# Строка1Строка2
# Кроме того, можно выnолнить неявную конкатенацию строк. 
# В этом случае две строки указываются рядом без оператора между ними:
print("Строка1" "Строка2")
# Строка1Строка2
# Обратите внимание на то, что если между строками указать запятую, то мы получим кортеж, а не строку:
s = "Строка1", "Строка2"
type(s)         # Получаем кортеж, а не строку
# <class 'tuple'>
# Если соединяются, например, переменная и строка, то следует обязательно указывать символ
# конкатенации строк, иначе будет выведено сообщение об ошибке:
s = "Строка1"
print(s + "Строка2")        # Нормально
# Строка1Строка2
# print(s "Строка2")        # Ошибка
# SyntaxError: invalid syntax

# При необходимости соединить строку с другим типом данных (например, с числом) следует
# произвести явное преобразование тиnов с помощью функции str():
"string" + str(10)
# 'string10'
# Кроме рассмотренных операций, строки поддерживают операцию повторения и проверку на вхождение.
# Повторить строку указанное количество раз можно с помощью оператора *,
# а выполнить проверку на вхождение фрагмента в строку позволяет оператор in:
"-" * 20
# '--------------------'
"yt" in "Python"
# True
"yt" in "Perl"
# Fa1se


# ======================= Форматирование строк ===================================

# Вместо соединения строк с помощью оператора + лучше использовать форматирование.
# Данная операция позволяет соединять строку с любым другим типом данных и выполняется
# быстрее конкатенации.
# ПРИМЕЧАНИЕ
# В последующих версиях Pythoп оператор форматирования % может быть удален.
# Вместо этого оператора в новом коде следует использовать метод format().
#
# Форматирование имеет следующий синтаксис:
# <Строка сnециального формата> % <Значения>
# Внутри nараметра <Строка сnециального формата> могут быть указаны сnецификаторы,
# имеющие следующий синтаксис:
# %[(<Ключ>)][<Флаг>][<Ширина>][.<Точность>]<Тиn nреобразования>
# Количество сnецификаторов внутри строки должно быть равно количеству элементов в nараметре <Значения>.
# Если исnользуется только один сnецификатор, то nараметр <Значения> может содержать одно значение,
# в nротивном случае необходимо nеречислить значения через заnятую внутри круглых скобок,
# создавая тем самым кортеж. Пример: ·
"%s" % 10
# '10'
"%s - %s - %s" % (10, 20, 30)
# '10 - 20 - 30'

# Параметры внутри сnецификатора имеют следующий смысл:

# - <Ключ> - ключ словаря. Если задан ключ, то в nараметре <Значения> необходимо указать словарь, а не кортеж. Пример:
"%(name)s - %(year)s" % {"year": 1978, "name": "Nik"}
# 'Nik- 1978'

# - <Флаг> - флаг преобразования. Может содержать следующие значения:

#   # - для восьмеричных значений добавляет в начало комбинацию символов 0о, 
#       для шестнадцатеричных значений добавляет комбинацию символов 0х (если используется тип х) 
#           или 0X (если используется тип X),
#       для вещественных чисел указывает всегда выводить дробную точку, даже если задано значение 0 в
#           параметре <Точность>:
print("%#o %#o %#o" % (0o77, 10, 10.5))
# 0о77 0о12 0о12
print("%#x %#x %#x" % (0xff, 10, 10.5))
# 0xff 0xa 0xa
print("%#X %#X %#X" % (0xff, 10, 10.5))
# 0XFF 0XA 0XA
print("%#.0F %.0F" % (300, 300))
# 300. 300

#   0 - задает наличие ведущих нулей для числового значения:
"'%d' - '%05d'" % (3, 3)        # 5 - ширина nоля
"'3' - '00003'"

#   - - задает выравнивание по левой границе области. По умолчанию используется
#       выравнивание по правой границе. Если флаг указан одновременно с флагом 0, то
#       действие флага 0 будет отменено. Пример:
"'%5d' - '%-5d'" % (3, 3)       # 5 - ширина nоля
# "'    3' - '3    '"
"'%05d' - '%-05d'" % (3, 3)
# "'00003' - '3    '"

#   nробел - вставляет пробел перед положительным числом. Перед отрицательным
#            числом будет стоять минус. Пример:
"'% d' - '% d'" % (-3, 3)
# "'-3' - ' 3'"

#   + - задает обязательный вывод знака, как для отрицательных, так и для положительных
#       чисел. Если флаг + указан одновременно с флагом nробел, то действие флага nробел
#       будет отменено. Пример:
"'%+d' - '%+d'" % (-3, 3)
"'-3' - '+3'"


# - <Ширина> - минимальная ширина поля. Если строка не помещается в указанную ширину,
#               то значение игнорируется и строка выводится полностью:
"'%10d' - '%-10d'" % (3, 3)
# "'         3' - '3         '"
"'%3s''%10s'" % ( "string", "string")
# "'string''    string'"
# Вместо значения можно указать символ "*". В этом случае значение следует задать внутри кортежа:
"'%*s''%10s'" % (10, "string", "str")
# "'    string''       str'"


# - <Точность> - количество знаков после точки для вещественных чисел. Перед этим параметром
#                обязательно должна стоять точка. Пример:
import math
"%s %f %.2f" % (math.pi, math.pi, math.pi)
# '3.141592653589793 3.141593 3.14'
# Вместо значения можно указать символ "*". В этом случае згачение следует задать внутри кортежа.
"'%*.*f'" % (8, 5, math.pi)
# "' 3.14159'"

# - <Тип преобразования> - задает тип преобразования. Параметр является обязательным.
# В параметре <Тип преобразования> могут быть указаны следующие символы:

#   s - преобразует любой объект в строку с помощью функции str():
print("%s" % ("Обычная строка"))
# Обычная строка
print("%s %s %s" % (10, 10.52, [1, 2, 3]))
# 10 10.52 [1, 2, 3]

#   r - преобразует любой объект в строку с помощью функции repr():
print("%r" % ("Обычная строка"))
# 'Обычная строка'

#   а - преобразует объект в строку с помощью функции ascii():
print("%a" % ("строка"))
# '\u0441\u0442\u0440\u043e\u043a\u0430'

#   c - выводит одиночный символ или преобразует числовое значение в символ.
#   В качестве примера выведем числовое значение и соответствующий этому значению символ:
for i in range(33, 127): print("%s => %c" % (i, i))
'''
33 => !
34 => "
35 => #
36 => $
37 => %
38 => &
39 => '
40 => (
41 => )
42 => *
43 => +
44 => ,
45 => -
46 => .
47 => /
48 => 0
49 => 1
50 => 2
51 => 3
52 => 4
53 => 5
54 => 6
55 => 7
56 => 8
57 => 9
58 => :
59 => ;
60 => <
61 => =
62 => >
63 => ?
64 => @
65 => A
66 => B
67 => C
68 => D
69 => E
70 => F
71 => G
72 => H
73 => I
74 => J
75 => K
76 => L
77 => M
78 => N
79 => O
80 => P
81 => Q
82 => R
83 => S
84 => T
85 => U
86 => V
87 => W
88 => X
89 => Y
90 => Z
91 => [
92 => \
93 => ]
94 => ^
95 => _
96 => `
97 => a
98 => b
99 => c
100 => d
101 => e
102 => f
103 => g
104 => h
105 => i
106 => j
107 => k
108 => l
109 => m
110 => n
111 => o
112 => p
113 => q
114 => r
115 => s
116 => t
117 => u
118 => v
119 => w
120 => x
121 => y
122 => z
123 => {
124 => |
125 => }
126 => ~
'''

#   d и i - возвращают целую часть числа:
print("%d %d %d" % (10, 25.6, -80))
# 10 25 -80
print("%i %i %i" % (10, 25.6, -80))
# 10 25 -80

#   o - восьмеричное значение:
print("%o %o %o" % (0o77, 10, 10.5))
# 77 12 12
print("%#o %#o %#o" % (0o77, 10, 10.5))
# 0o77 0o12 0o12

#   х - шестнадцатеричное значение в нижнем регистре:
print("%x %x %x" % (0xff, 10, 10.5))
# ff а а
print("%#x %#x %#x" % (0xff, 10, 10.5))
# 0xff 0xa 0xa

#   х - шестнадцатеричное значение в верхнем регистре:
print("%X %X %X" % (0xff, 10, 10.5))
# FF А А
print("%#X %#X %#X" % (0xff, 10, 10.5))
# 0XFF 0XA 0XA

#   f и F - вещественное число в десятичном представлении:
print("%f %f %f" % (300, 18.65781452, - 12.5))
# 300.000000 18.657815 -12.500000
print("%F %F %F" % (300, 18.65781452, -12.5))
# 300.000000 18.657815 -12.500000
print("%#.0F %.0F" % (300, 300))
# 300. 300

#   е - вещественное число в экспоненциальной форме (буква "е" в нижнем регистре):
print("%e %e" % (3000, 18657.81452))
# 3.000000e+03 1.865781e+04

#   Е - вещественное число в экспоненциальной форме (буква "е" в верхнем регистре):
print("%E %E" % (3000, 18657.81452))
# 3.000000E+03 1.865781E+04

#   g - эквивалентно f или е (выбирается более короткая запись числа):
print("%g %g %g" % (0.086578, 0.000086578, 1.865E-005))
# 0.086578 8.6578e-05 1.865e-05

#   G - эквивалентно f или Е (выбирается более короткая запись числа):
print("%G %G %G" % (0.086578, 0.000086578, 1.865E-005))
# 0.086578 8.6578E-05 1.865E-05

# Если внутри строки необходимо использовать символ процента, то этот символ следует
# удвоить, иначе будет выведено сообщение об ошибке:
#print("% %s" % ("- это символ процента"))          # Ошибка
#Traceback (most recent call last) :
#   File "<pyshell#'SS>", line 1, i n <rnoclule>    # Ошибка
#TypeError: not all arguments converted during string formatting
print("%% %s" % ("- это символ процента "))         # Нормально
# % - это символ процента

# Форматирование строк очень удобно исnользовать nри nередаче данных в шаблон НТМL-страницы.
# Для этого заnолняем словарь данными и указываем его сnрава от символа %, а сам шаблон - слева.
# Пример использования форматирования строк:

# -*- coding: utf-8 -*-
html = """<html>
<head><title>%(title)s</title>
</head>
<body>
<h1>%(h1)s</h1>
<div>%(content)s</div>
</body>
</html>"""
arr = {"title": "Это название документа",
"h1": "Это заголовок: nервого уровня",
"content": "Это основное содержание страницы"}
print(html % arr)           # Подставляем значения и выводим шаблон
input()

'''
Результат выполнения:

<html>
<head><title>Это название документа</title>
</head>
<body>
<h1>Это заголовок первого уровня</h1>
<div>Это основное содержание страницы</div>
</body>
</html>
'''

# Для форматирования строк можно также использовать следующие методы:

#   expandtabs([<Ширина nоля>]) - заменяет символ табуляции пробелами таким образом,
#       чтобы общая ширина фрагмента вместе с текстом (расположенным перед символом табуляции)
#       была равна указанной величине. Если параметр не указан, то ширина поля
#       предполагается равной 8 символам. Пример:
s = "1\t12\t123\t"
"%s" % s.expandtabs(4)
# '1   12  123 '
# В этом примере ширина задана равной четырем символам. Поэтому во фрагменте "1\t"
# табуляция будет заменена тремя пробелами, во фрагменте "12\t"- двумя пробелами, а
# во фрагменте "123\t" - одним пробелом. Во всех трех фрагментах ширина будет равна
# четырем символам.

# Если перед символом табуляции нет текста или количество символов перед табуляцией
# равно ширине, то табуляция заменяется указанным количеством пробелов:
s = "\t"
"'%s'- '%s'" % (s.expandtabs(), s.expandtabs(4))
# "'        '- '    '"
s = "1234\t"
"'%s'" % s.expandtabs(4)
# "'1234    '"

# Если количество символов перед табуляцией больше ширины, то табуляция заменяется
# пробелами таким образом, чтобы ширина фрагмента вместе с текстом делилась без остатка
# на указанную ширину:
s = "12345\t123456\t1234567\t1234567890\t"
"'%s'" % s.expandtabs(4)
"'12345   123456  1234567 1234567890  '"
# Таким образом, если количество символов перед табуляцией больше 4, но менее 8, то
# фрагмент дополняется пробелами до 8 символов. Если количество символов больше 8,
# но менее 12, то фрагмент дополняется пробелами до 12 символов и т. д. Все это справедливо
# при указании в качестве параметра числа 4;

#   center(<Ширина>[, <Символ>]) - производит выравнивание строки по центру внутри
#       поля, указанной ширины. Если второй параметр не указан, то справа и слева от исходной
#       строки будут добавлены пробелы. Пример:
s = "str"
s.center(15), s.center(11, "-")
# ('      str      ', '----str----')
# Теперь произведем выравнивание трех фрагментов шириной 15 символов. Первый
# фрагмент будет выровнен по правому краю, второй - по левому, а третий - по центру:
s = "str"
"'%15s' '%-15s' '%s'" % (s, s, s.center(15))
# "'            str' 'str            ' '      str      '"
# Если количество символов в строке превышает ширину поля, то значение ширины игнорируется
# и строка возвращается полностью:
s = "string"
s.center(6), s.center(5)
# ('string', 'string')

#  ljust(<Ширина>[, <Символ>])- производит выравнивание строки по левому краю
#       внутри поля указанной ширины. Если второй параметр не указан, то справа от исходной
#       строки будут добавлены пробелы. Если количество символов в строке превышает ширину
#       поля, то значение ширины игнорируется и строка возвращается полностью. Пример:
s = "string"
s.ljust(15), s.ljust(15, "-")
# ('string         ', 'string---------')
s.ljust(6), s.ljust(5)
# ('string', 'string')

#   rjust(<Ширина>[, <Символ>]) - производит выравнивание строки по правому краю
#       внутри поля указанной ширины. Если второй параметр не указан, то слева от исходной
#       строки будут добавлены пробелы. Если количество символов в строке превышает ширину
#       поля, то значение ширины игнорируется и строка возвращается полностью. Пример:
s = "string"
s.rjust(15), s.rjust(15, "-")
# ('         string', '---------string')
s.rjust(6), s.rjust(5)
# ('string', 'string')

#   zfill(<Ширина>) - производит выравнивание фрагмента по правому краю внутри поля
#       указанной ширины. Слева от фрагмента будут добавлены нули. Если количество символов
#       в строке превышает ширину поля, то значение ширины игнорируется и строка возвращается
#       полностью. Пример:
"5".zfill(20), "123456".zfill(5)
# ('00000000000000000005', '123456')


# =============================== Метод format() ============================================

# Начиная с Python 2.6. помимо операции форматирования, строки поддерживают метод format().
# Метод имеет следующий синтаксис:

# <Строка> = <Строка специального фopмaтa>.format(*args, **kwargs)

# В параметре <Строка специального формата> внутри символов { и } указываются спецификаторы,
# имеющие следующий синтаксис:

# {[<Поле>][!<Функция>][:<Формат>]}

# Все символы, расположенные вне фигурных скобок, выводятся без преобразований. 
# Если внутри строки необходимо использовать символы { и }, то эти символы следует удвоить,
# иначе возбуждается исключение ValueError. Пример:
print("Символы {{ и }} - {0}".format("сnециальные",))
# Символы { и } - сnециальные

# В параметре <Поле> можно указать индекс позиции (нумерация начинается с нуля) или ключ.
# Допустимо комбинировать позиционные и именованные параметры. В этом случае
# в методе format() именованные параметры указываются в самом конце. Пример:
"{0} - {1} - {2}".format(10, 12.3, "string")            # Индексы
# '10 - 12.3 - string'
arr = [10, 12.3, "string"]
"{0} - {1} - {2}".format(*arr)                          # Индексы
# '10 - 12.3 - string'
"{model} - {color}".format(color="red", model="BМW")    # Ключи
# 'BМW - red'
d = {"color": "red", "model": "ВМW"}
"{model} - {color}".format(**d)                         # Ключи
# 'ВМW- red'
"{color} - {0}".format(2010, color="red")               # Комбинация
# 'red - 2010'

# В качестве параметра в методе format() можно указать объект.
# Для доступа к элементам по индексу внутри строки формата применяются квадратные скобки,
# а для доступа к атрибутам объекта используется точечная нотация:
arr = [10, [12.3, "string"]]
"{0[0]} - {0[1][0]} - {0[1][1]}".format(arr)            # Индексы
# '10 - 12.3 - string'
"{arr[0]} - {arr[1][1]}".format(arr=arr)                # Индексы
# '10 - string'
class Car: color, model = "red", "ВМW"

car = Car()
"{0.model} - {0.color}".format(car)                     # Атрибуты
# 'ВМW - red'

# Существует также краткая форма записи, при которой параметр <Поле> не указывается.
# В этом случае скобки без указанного индекса нумеруются слева направо, начиная с нуля:
"{} - {} - {} - {n}".format(1, 2, 3, n=4)               # "{0} - {1} - {2} - {n}"
# '1 - 2 - 3 - 4'
"{} - {} - {n} - {}".format(1, 2, 3, n=4)               # "{0) - {1) - {n) - {2}"
# '1 - 2 - 4 - 3'

# Параметр <Функция> задает функцию, с помощью которой обрабатываются данные перед вставкой в строку.
# Если указано значение "s", то данные обрабатываются функцией str(),
# если значение "r", то функцией repr(), а если значение "а", то функцией ascii().
# Если параметр не указан, то для преобразования данных в строку используется функция str(). Пример:
print("{0!s}".format("строка"))                         # str ()
# строка
print("{0!r}".format("строка"))                         # repr()
# 'строка'
print("{0!a}".format("строка"))                         # ascii()
# '\u0441\u0442\u0440\u043e\u043a\u0430'

# В параметре <Формат> указывается значение, имеющее следующий синтаксис:
# [[<Заполнитель>]<Выравнивание>][<Знак>][#][0][<Ширина>][,][.<Точность>][<Преобразование>]

# Параметр <Ширина> задает минимальную щирину nоля.
# Если строка не помещается в указанную ширину, то значение игнорируется и строка выводится полностью:
"'{0:10}' '{1:3}'".format(3, "string")
# "'         3' 'string'"
# Ширину поля можно передать в качестве параметра в методе format().
# В этом случае вместо числа указывается индекс параметра внутри фигурных скобок:
"'{0:{1}}'".format(3, 10)                               # 10 - это ширина поля
# "'         3'"
# По умолчанию, значение внутри поля выравнивается по правому краю.

# Управлять выравниванием позволяет параметр <Выравнивание>. Можно указать следующие значения:
# < - по левому краю;
# > - по nравому краю;
# ^ - по центру nоля. Пример:
"'{0:<10}' '{1:>10}' '{2:^10}'".format(3, 3, 3)
# "'3         ' '         3' '    3     '"
# = - знак числа выравнивается по левому краю, а число по правому краю:
"'{0:=10}' '{1:=10}'".format(-3, 3)
# "'-        3' '         3'"
# Как видно из предыдущего примера, пространство между знаком и числом по умолчанию
# заполняется пробелами, а знак положительного числа не указывается. Чтобы вместо пробелов
# пространство заполнялось нулями, необходимо указать нуль перед шириной поля:
"'{0:=010}' '{1:=010}'".format(-3, 3)
# "'-000000003' '0000000003'"

# Такого же эффекта можно достичь, указав нуль в параметре <Заполнитель>. В этом параметре
# допускаются и другие символы, которые будут выводиться вместо пробелов:
"'{0:0=10}' '{1:0=10}'".format(-3, 3)
# "'-000000003' '0000000003'"
"'{0:*<10}' '{1:+>10}' '{2:.^10}'".format(3, 3, 3)
# "'3*********' '+++++++++3' '....3.....'"

# Управлять выводом знака числа позволяет параметр <Знак>. Допустимые значения:
# + - задает обязательный вывод знака как для отрицательных, так и для положительных чисел;
# - - вывод знака только для отрицательных чисел (значение по умолчанию);
# пробел - вставляет пробел перед положительным числом.
#          Перед отрицательным числом будет стоять минус. Пример:
"'{0:+}' '{1:+}' '{0:-}' '{1:-}'".format(3, -3)
# "'+3' '-3' '3' '-3'"
"'{0: }' '{1: }'".format(3, -3)                         # Пробел
"' 3' '-3'"

# Для целых чисел в параметре <Преобразование> могут быть указаны следующие опции:
# b - двоичное значение:
"'{0:b}' '{0:#b}'".format(3)
# "'11' '0b11'"

# c - преобразует целое число в соответствующий символ:
"'{0:c}'".format(100)
# "'d'"

# d - десятичное значение;

# n - аналогично опции d, но учитывает настройки локали. Например, выведем большое
#     число с разделением тысячных разрядов пробелом:
import locale
locale.setlocale(locale.LC_NUMERIC, 'Russian_Russia.1251')
# 'Russian_Russia.1251'
print("{0:n}".format(100000000).replace("\uffa0", " "))
# 100 000 000
# В Python 3.2.0 между разрядами вставляется символ с кодом \uffa0, который отображается
# квадратиком. Чтобы вывести символ пробела, мы производим замену в строке с помощью
# метода replace(). В версии 2.6 поведение было другим. Там вставлялся символ с
# кодом \xa0 и не нужно было производить замену. Чтобы в Python 3.2.0 вставлялся символ
# с кодом \xa0, следует ВОСПОЛЬЗОВАТЬСЯ функцией format() из модуля lосаlе:
import locale
locale.setlocale(locale.LC_NUMERIC, "Russian_Russia.1251")
# 'Russian_Russia.1251'
print(locale.format("%d", 100000000, grouping=True))
# 100 000 000
locale.localeconv()["thousands_sep"]
# '\xa0'
# Можно также разделить тысячные разряды запятой, указав ее в строке формата:
print("{0:,d}".format(100000000))
# 100,000,000

# o - восьмеричное значение:
"'{0:d}' '{0:o}' '{0:#o}'".format(511)
"'511' '777' '0o777'"

# x - шестнадцатеричное значение в нижнем регистре:
"'{0:x}' '{0:#x}'".format(255)
# "'ff' '0xff'"

# X - шестнадцатеричное значение в верхнем регистре:
"'{0:X}' '{0:#X}'".format(255)
# "'FF' '0XFF'"

# Для вещественных чисел в nараметре <Преобразование> могут быть указаны следующие опции:

# f и F - вещественное число в десятичном представлении:
"'{0:f}' '{1:f}' '{2:f}'".format(30, 18.6578145, -2.5)
# "'30.000000' '18.657815' '-2.500000'"
# Задать количество знаков после запятой позволяет параметр <Точность>:
"'{0:.7f}' '{1:.2f}'".format(18.6578145, -2.5)
# "'18.6578145' '-2.50'"

# e - вещественное число в экспоненциальной форме (буква "е" в нижнем регистре):
"'{0:e}' '{1:e}'".format(3000, 18657.81452)
# "'3.000000e+03' '1.865781e+04'"

# E - вещественное число в экспоненциальной форме (буква "е" в верхнем регистре):
"'{0:E}' '{1:E}'".format(3000, 18657.81452)
# "'3.000000E+03' '1.865781E+04'"

# g - эквивалентно f или е (выбирается более короткая заnись числа):
"'{0:g}' '{1:g}'".format(0.086578, 0.000086578)
# "'0.086578' '8.6578e-05'"

# n - аналогично опции g, но учитывает настройки локали;

# G - эквивалентно f или Е (выбирается более короткая запись числа):
"'{0:G}' '{1:G}'".format(0.086578, 0.000086578)
# "'0.086578' '8.6578E-05'"

# % - умножает число на 100 и добавляет символ процента в конец. Значение отображается
# в соответствии с опцией f. Пример:
"'{0:%}' '{1:.4%}'".format(0.086578, 0.000086578)
# "'8.657800%' '0.0087%'"

# ============================= Функции и методы для работы со строками ========================
# Основные функции для работы со строками:

# str([<Объект>]) - преобразует любой объект в строку.
#   Если nараметр не указан, то возвращается пустая строка.
#   Используется функцией print() для вывода объектов. Пример:
str(), str([1, 2]), str((3, 4)), str({"x": 1})
# ('', '[1, 2]', '(3, 4)', "{'x': 1}")
print("строка1 \nстрока2")
# строка1
# строка2

# repr(<Объект>) - возвращает строковое представление объекта.
#   Используется nри выводе объектов в окне Python Shell редактора IDLE. Пример:
repr("Строка"), repr([1, 2, 3]), repr({"x": 5})
# ("'Строка'", '[1, 2, 3]', "{'x': 5}")
repr("строка1 \nстрока2")
# "'строка1 \\nстрока2'"

# ascii(<Объект>) - возвращает строковое nредставление объекта.
#   В строке могут быть символы только из кодировки ASCII. Пример:
ascii([1, 2, 3]), ascii({"x": 5})
# ('[1, 2, 3]', "{'x': 5}")
ascii("строка")
# "'\\u0441\\u0442\\u0440\\u043e\\u043a\\u0430'"

# len(<Строка>) - возвращает количество символов в строке:
len("Python"), len("\r\n\t"), len(r"\r\n\t")
# (6, 3, 6)
len("строка")
# 6

# Основные методы для работы со строками:

# strip([<Символы>]) - удаляет пробельные или указанные символы в начале и конце строки.
#   Пробельными символами считаются: пробел, символ nеревода строки (\n), символ
#   возврата каретки (\r), символы горизонтальной (\t) и вертикальной (\v) табуляции:
s1, s2 = "     str\n\r\v\t", "strstrstrokstrstrstr"
"'%s' - '%s'" % (s1.strip(), s2.strip("tsr"))
# "'str' - 'ok'"

# lstrip([<Символы>]) - удаляет nробельные или указанные символы в начале строки:
s1, s2 = "     str     ", "strstrstrokstrstrstr"
"'%s' - '%s'" % (s1.lstrip(), s2.lstrip("tsr"))
# "'str     ' - 'okstrstrstr'"

# rstrip([<Символы>]) - удаляет nробельные или указанные символы в конце строки:
s1, s2 = "     str     ", "strstrstrokstrstrstr"
"'%s' - '%s'" % (s1.rstrip(), s2.rstrip("tsr"))
# "'     str' - 'strstrstrok'"

# split([<Разделитель>[, <Лимит>]]) - разделяет строку на подстроки по указанному
#   разделителю и добавляет их в список.
#   Если первый параметр не указан или имеет значение None, то в качестве разделителя
#   используется символ пробела.
#   Если во втором параметре задано число, то в списке будет указанное количество подстрок.
#   Если подстрок больше указанного количества, то список будет содержать еше один элемент, в котором
#   будет остаток строки. Примеры:
s = "word1 word2 word3"
s.split(), s.split(None, 1)
# (['word1', 'word2', 'word3'], ['word1', 'word2 word3'])
s = "word1\nword2\nword3"
s.split("\n")
# ['word1', 'word2', 'word3']
# Если в строке содержатся несколько пробелов подряд и разделитель не указан, то пустые
# элементы не будут добавлены в список:
s = "word1     word2 word3    "
s.split()
# ['word1', 'word2', 'word3']
# При использовании другого разделителя могут быть пустые элементы:
s = ",,word1,,word2,,word3,,"
s.split(",")
# ['', '', 'word1', '', 'word2', '', 'word3', '', '']
"1,,2,,3".split(",")
# ['1', '', '2', '', '3']
# Если разделитель не найден в строке, то список будет состоять из одного элемента,
# представляюшего исходную строку:
"word1 word2 word3".split("\n")
# ['word1 word2 word3']

# rsрlit([<Разделитель>[, <Лимит>]])- метод,аналогичен методу split(), но поиск
#   символа-разделителя производится не слева направо, а, наоборот, справа налево. Примеры:
s = "word1 word2 word3"
s.rsplit(), s.rsplit(None, 1)
# (['word1', 'word2', 'word3'], ['word1 word2', 'word3'])
"word1\nword2\nword3".rsplit("\n")
# ['word1', 'word2', 'word3']

# splitlines([True]) - разделяет строку на подстроки по символу перевода строки (\n) и
#   добавляет их в список. Символы новой строки включаются в результат, только если необязательный
#   параметр имеет значение True. Если разделитель не найден в строке, то
#   список будет содержать только один элемент. Примеры:
"word1\nword2\nword3".splitlines()
# ['word1', 'word2', 'word3']
"word1\nword2\nword3".splitlines(True)
# ['word1\n', 'word2\n', 'word3']
"word1\nword2\nword3".splitlines(False)
# ['word1', 'word2', 'word3']
"word1 word2 word3".splitlines()
# ['word1 word2 word3']

#  partition(<Разделитель>) - находит первое вхождение символа-разделителя в строку и
#   возвращает кортеж из трех элементов. Первый элемент будет содержать фрагмент, расположенный
#   перед разделителем, второй элемент - символ-разделитель, а третий элемент -
#   фрагмент, расположенный после символа-разделителя. Поиск производится слева
#   направо. Если символ-разделитель не найден, то первый элемент кортежа будет содержать
#   всю строку, а остальные элементы будут пустыми. Пример:
"word1 word2 word3".partition(" ")
# ('word1', ' ', 'word2 word3')
"word1 word2 word3".partition("\n")
# ('word1 word2 word3', '', '')

# rpartition(<Разделитель>) - метод аналогичен методу partition (), но поиск символа-разделителя
#   производится не слева направо, а, наоборот, справа налево. Если символ-разделитель
#   не найден, то первые два элемента кортежа будут пустыми, а третий элемент
#   будет содержать всю строку. Пример:
"word1 word2 word3".rpartition(" ")
# ('word1 word2', ' ', 'word3')
"word1 word2 word3".rpartition("\n")
# ('', '', 'word1 word2 word3')

# join() - преобразует последовательность в строку. Элементы добавляются через указанный
#   разделитель. Формат метода:
#   <Строка> = <Разделитель>.jоin(<Последовательность>)
#   В качестве примера преобразуем список и кортеж в строку:
" => ".join(["word1", "word2", "word3"])
# 'word1 => word2 => word3'
" ".join(("word1", "word2", "word3"))
# 'word1 word2 word3'

# Обратите внимание на то, что элементы последовательностей должны быть строками,
# иначе возбуждается исключение TypeError:
# " ".join(("word1", "word2", 5))
#Traceback (most recent call last):
#  File "<pyshell#192>", line 1, in <module>
#    " ".join(("word1", "word2", 5))
#TypeError: sequence item 2: expected str instance, int found

# Как вы уже знаете, строки относятся к неизменяемым типам данных. Если попытаться
# изменить символ по индексу, то возникнет ошибка. Чтобы изменить символ по индексу
# можно преобразовать строку в список с помощью функции list(), произвести изменения,
# а затем с помощью метода join() преобразовать список обратно в строку. Пример:
s = "Python"
arr = list(s); arr              # Преобразуем строку в список
# ['Р', 'у', 't', 'h', 'о', 'n']
arr[0] = "J"; arr               # Изменяем элемент по индексу
# ['J', 'y', 't', 'h', 'o', 'n']
s = "".join(arr); s             # Преобразуем список в строку
# 'Jython'

# В Python 3 можно также преобразовать строку в тип bytearray, а затем изменить символ
# пo индексу:
s = "Python"
b = bytearray(s, "cp1251"); b   # Преобразуем строку в тип bytearray
# bytearray(b'Python')
b[0] = ord("J"); b              # Изменяем символ пo индексу
# bytearray(b'Jython')
s = b.decode("cp1251"); s       # Преобразуем тип bytearray в строку
# 'Jython'


# ============================= Настройка локали ====================================

# Для установки локали (совокупности локальных настроек системы) используется функция
# setlocale() из модуля lосаlе. Прежде чем использовать функцию, необходимо подключить
# модуль с помощью выражения:

import locale

# Функция setlocale() имеет следующий формат:

# setlocale(<Категория> [,<Локаль>]);

# Параметр <Категория> может принимать следующие значения:

# locale.LC_ALL         - устанавливает локаль для всех режимов;
# locale.LC_COLLATE     - для сравнения строк;
# locale.LC_CTYPE       - для перевода символов в нижний или верхний регистр;
# locale.LC_MONETARY    - для отображения денежных единиц;
# locale.LC_NUMERIC     - для форматирования чисел;
# locale.LC_TIME        - для форматирования вывода даты и времени.

# Получить текущее значение локали позволяет функция getlocale([<Категория>]).
# В качестве примера настроим локаль под Windows вначале на кодировку Windows-1251, потом
# на кодировку UTF-8, а затем на кодировку по умолчанию. Далее выведем текущее значение
# локали для всех категорий и только для locale.LC_COLLATE
import locale
# Для кодировки windows-1251
locale.setlocale(locale.LC_ALL, "Russian_Russia.1251")
# 'Russian_Russia.1251'

# Для кодировки UTF-8
# locale.setlocale(locale.LC_ALL, "utf-8")   # ВЫЯСНИТЬ ??? 
# 

# Устанавливаем локаль по умолчанию
locale.setlocale(locale.LC_ALL, "")
# 'Ukrainian_Ukraine.1251'
# Получаем текущее значение локали для всех категорий
locale.getlocale()
# ('Ukrainian_Ukraine', '1251')
# Получаем текущее значение категории locale.LC_COLLATE
locale.getlocale(locale.LC_COLLATE)
# ('Ukrainian_Ukraine', '1251')

# Получить настройки локали позволяет функция localeconv(). Функция возвращает словарь
# с настройками. Результат выполнения функции для локали Russian_Russia.1251 выглядит
# следующим образом:
locale.localeconv()
'''
{'p_sign_posn': 1, 'frac_digits': 2, 'thousands_sep': '\xa0', 'p_sep_by_space': 0, 'grouping': [3, 0],
'mon_thousands_sep': '\xa0', 'currency_symbol': '?', 'mon_decimal_point': '.',
'negative_sign': '-', 'n_cs_precedes': 0, 'int_frac_digits': 2, 'n_sign_posn': 1,
'mon_grouping': [3, 0], 'decimal_point': '.', 'int_curr_symbol': 'UAH', 'p_cs_precedes': 0,
'n_sep_by_space': 0, 'positive_sign': ''}
'''


# ========================= Изменение регистра символов =============================
# Для изменения регистра символов предназначены следующие методы:

# upper()       - заменяет все символы строки соответствующими прописными буквами:
print("все символы строки станут прописными".upper())
# ВСЕ СИМВОЛЫ СТРОКИ СТАНУТ ПРОПИСНЫМИ

# lower()       - заменяет все символы строки соответствующими строчными буквами:
print("все СИМВОЛЫ СТРОКИ станут СТРОЧНЫМИ".lower())
# все символы строки станут строчными

# swapcase()    - заменяет все строчные символы соответствующими прописными буквами,
#                 а все прописные символы - строчными:
print("ВСЕ ПРОПИСНЫЕ СИМВОЛЫ СТАНУТ СТРОЧНЫМИ, а строчные - прописными".swapcase())
# все прописные символы станут строчными, А СТРОЧНЫЕ - ПРОПИСНЫМИ

# capitalize()  - делает первую букву прописной:
print("первая буква строки станет прописной".capitalize())
# Первая буква строки станет прописной

# title()       - делает первую букву каждого слова прописной:
s = "первая буква каждого слова станет прописной"
print(s.title())
# Первая Буква Каждого Слова Станет Прописной


# ============================ Функции для работы ·с ·символами ========================
# Для работы с отдельными символами предназначены следующие функции:

# chr(<Код символа>)    - возвращает символ по указанному коду:
print(chr(1055))
# П

# ord(<Символ>)         - возвращает код указанного символа:
print(ord("П"))
# 1055


# =========================== Поиск и замена в строке =================================
# Для поиска и замены в строке используются следующие методы:

# find() - ищет подстроку в строке. Возвращает номер позиции, с которой начинается
#   вхождение подстроки в строку. Если подстрока в строку не входит, то возвращается значение
#   -1. Метод зависит от регистра символов. Формат метода:

# <Строка>.find(<Подстрока>[, <Начало>[, <Конец>]])

# Если начальная позиция не указана, то поиск будет осуществляться с начала строки.
# Если параметры <Начало> и <Конец> указаны, то производится операция извлечения среза
# <Строка>[<Начало>:<Конец>]
# и поиск подстроки будет выполняться в этом фраrменте. Пример:
s = "пример пример Пример"
s.find("при"), s.find("При"), s.find("тест")
# (0, 14, -1)
s.find("при", 9), s.find("при", 0, 6), s.find("при", 7, 12)
# (-1, 0, 7)

# index() - метод аналогичен методу find (), но если подстрока в строку не входит, то
#   возбуждается исключение ValueError. Формат метода:

# <Строка>.indех(<Подстрока>[, <Начало>[, <Конец>]])

# Пример:
s = "пример пример Пример"
s.index("при"), s.index("при", 7, 12), s.index("При", 1)
# (0, 7, 14)

# s.index("тecт")
#Traceback (most recent call last):
#  File "<pyshell#237>", line 1, in <module>
#    s.index("тecт")
#ValueError: substring not found

# rfind() - ищет подстроку в строке. Возвращает позицию последнего вхождения подстроки
#   в строку. Если подстрока в строку не входит, то возвращается значение -1. Метод
#   зависит от регистра символов. Формат метода:

# <Строка>.rfind(<Подстрока>[, <Начало>[, <Конец>]])

# Если начальная позиция не указана, то поиск будет производиться с начала строки. Если
# параметры <Начало> и <Конец> указаны, то выполняется операция извлечения среза, и
# поиск подстроки будет производиться в этом фрагменте. Пример:
s = "пример пример Пример Пример"
s.rfind("при"), s.rfind("При"), s.rfind("тecт")
# (7, 21, -1)
s.find("при", 0, 6), s.find("При", 10, 20)
# (0, 14)

# rindex() - метод аналогичен методу rfind(), но если подстрока в строку не входит, то
#   возбуждается исключение Va1ueError. Формат метода:

# <Строка>.rindех(<Подстрока>[, <Начало>[, <Конец>]])

# Пример:
s = "пример пример Пример Пример"
s.rindex("при"), s.rindex("При"), s.rindex("при", 0, 6)
# (7, 21, 0)

# s.rindex("тест")
#Traceback (most recent call last):
#  File "<pyshell#247>", line 1, in <module>
#    s.rindex("тест")
#ValueError: substring not found

# count() - возвращает число вхождений подстроки в строку. Если подстрока в строку не
#   входит, то возвращается значение 0. Метод зависит от регистра символов. Формат метода:

# <Строка>.соunt(<Подстрока>[, <Начало>[, <Конец>]])

# Пример:
s = "пример пример Пример Пример"
s.count("при"), s.count("при", 6) , s.count("При")
# (2, 1, 2)
s.count("тест")
# 0

# startswith() - проверяет, начинается ли строка с указанной подстроки. Если начинается,
#   то возвращается значение True, в противном случае - False. Метод зависит от регистра
#   символов. Формат метода:

# <Cтpoкa>.startswith(<Пoдcтpoкa>[, <Начало>[, <Конец>]])

# Если начальная позиция не указана, сравнение будет производиться с началом строки.
# Если параметры <Начало> и <Конец> указаны, то выполняется операция извлечения среза,
# и сравнение будет производиться с началом фрагмента. Пример:
s = "пример пример Пример Пример"
s.startswith("при"), s.startswith("При")
# (True, False)
s.startswith("при", 6), s.startswith("При", 14)
# (False, True)

# Начиная с версии 2.5 параметр <Подстрока> может быть кортежем:
s = "пример пример Пример Пример"
s.startswith(("при", "При"))
# True

# endswith() - проверяет, заканчивается ли строка указанной nодстрокой. Если заканчивается,
#   то возвращается значение True, в nротивном случае- Fa1se. Метод зависит от
#   регистра символов. Формат метода:

# <Строка>.еnd5with(<Подстрока>[, <Начало>[, <Конец>]])

# Если начальная позиция не указана, то сравнение будет производиться с концом строки.
# Если параметры <Начало> и <Конец> указаны, то выполняется операция извлечения среза,
# и сравнение будет производиться с концом фрагмента. Пример:
s = "подстрока ПОДСТРОКА"
s.endswith("ока"), s.endswith("ОКА")
# (False, True)
s.endswith("ока", 0, 9)
# True

# Начиная с версии 2.5, параметр <Подстрока> может быть кортежем:
s = "подстрока ПОДСТРОКА"
s.endswith(("ока", "ОКА"))
# True

# replace() - производит замену всех вхождений подстроки в строку на другую подстроку
#   и возвращает результат в виде новой строки. Метод зависит от регистра символов.
#   Формат метода:

# <Строка>.rерlасе(<Подстрока для замены, <Новая подстрока>[, <Максимальное количество замен>])

# Пример:
s = "Привет, Петя"
print(s.replace("Петя", "Вася"))
# Привет, Вася
print(s.replace("пeтя", "вася"))    #Зависит от регистра
# Привет, Петя
s = "strstrstrstrstr"
s.replace("str", ""), s.replace("str", "", 3)
('', 'strstr')

# translate(<Таблица символов>) - заменяет символы в соответствии с параметром <Таблица
#   символов>. Параметр <Таблица символов> должен быть словарем, ключами которого
#   являются Unicode-кoды заменяемых символов, а значениями - Unicode-кoды вставляемых
#   символов. Если в качестве значения указать None, то символ будет удален. Для
#   примера удалим букву "П", а также изменим регистр всех букв "р":
s = "Пример"
d = {ord("П"): None, ord("р"): ord("Р")}
d
# {1088: 1056, 1055: None}
s.translate(d)
# 'РимеР'

# Упростить создание <Таблицы символов> позволяет статический метод maketrans().
# Формат метода:

# str.maketrans(<X>[, <У>[, <Z>]])

# Если указан только первый параметр, то он должен быть словарем:
t = str.maketrans({"а": "А", "о": "О", "с": None})
t
# {1072: 'А', 1089: None, 1086: 'О'}
"строка".translate(t)
# 'трОкА'
# Если указаны два первых параметра, то они должны быть строками одинаковой длины.
# В результате будет создан словарь с ключами из строки <Х> и значениями, расположенными
# в той же позиции, из строки <У>. Изменим регистр некоторых символов:
t = str.maketrans("абвгдежзи", "АБВГДЕЖЗИ")
t
# {1072: 1040, 1073: 1041, 1074: 1042, 1075: 1043, 1076: 1044, 1077: 1045,
# 1078: 1046, 1079: 1047, 1080: 1048}
"абвгдежзи".translate(t)
# 'АБВГДЕЖЗИ'
# В третьем параметре можно дополнительно указать строку из символов, которым будет
# сопоставлено значение None. После выполнения метода translate() эти символы будут
# удалены из строки. Заменим все цифры на 0, а некоторые буквы удалим из строки:
t = str.maketrans("123456789", "0" * 9, "str")
t
# {51: 48, 116: None, 114: None, 49: 48, 50: 48, 115: None, 52: 48, 53: 48, 54: 48,
#  55: 48, 56: 48, 57: 48}
"str123456789str".translate(t)
# '000000000'


# ============================= Проверка типа содержимого строки ======================

# Для проверки типа содержимого предназначены следующие методы:

# isdigit() - возвращает True, если строка содержит только цифры, в противном случае - False:
"0123".isdigit(), "123abc".isdigit(), "abcl23".isdigit()
#(True, False, False)

# isdecimal() - возвращает True, если строка содержит только десятичные символы,
#               в противном случае - False.
# Обратите внимание на то, что к десятичным символам относятся
# не только десятичные цифры в кодировке ASCII, но и надстрочные и подстрочные
# десятичные цифры в других языках. Пример:
"123".isdecimal(), "123cтp".isdecimal()
# (True, False)

# isnumeric() - возвращает True, если строка содержит только числовые символы, в противном
#               случае - False.
# Обратите внимание на то, что к числовым символам относятся не только десятичные цифры в
# кодировке ASCII, но символы римских чисел, дробные числа и др. Пример:
"\u2155".isnumeric(), "\u2155".isdigit()
# (True, False)
print("\u2155")     # Выведет символ "1/5"

# isalpha() - возвращает True, если строка содержит ТОЛЬКО БУКВЫ, в противном случае - False.
# Если строка пустая, то возвращается значение False. Примеры:
"string".isalpha(), "cтpoкa".isalpha(), "".isalpha()
# (True, True, False)
"123abc".isalpha(), "str str".isalpha(), "st,st".isalpha()
# (False, False, False)

# isspace() - возвращает True, если строка содержит только пробельные символы, в противном случае - False:
"".isspace(), "\n\r\t".isspace(), "str str".isspace()
# (False, True, False)

# isalnum() - возвращает True, если строка содержит только буквы и (или) цифры, в противном случае - False.
# Если строка пустая, то возвращается значение False. Примеры:
"0123".isalnum(), "123abc".isalnum(), "abc123".isalnum()
# (True, True, True)
"cтpoкa".isalnum()
# True
"".isalnum(), "123 аЬс".isalnum(), "аbс, 123.".isalnum()
# (False, False, False)

# islower() - возвращает True, если строка содержит буквы, и они все в нижнем регистре, в противном случае - False.
#             Помимо букв строка может иметь другие символы, например цифры. Примеры:
"srting".islower(), "cтpoкa".islower(), "".islower(), "wdwd34rcrc23".islower()
# (True, True, False, True)
"srtingl".islower(), "str, 123".islower(), "123".islower()
# (True, True, False)
"STRING".islower(), "Строка".islower ()
# (False, False)

# isupper() - возвращает True, если строка содержит буквы, и они все в верхнем регистре, в противном случае - False.
#             Помимо букв строка может иметь другие символы, например цифры. Примеры:
"STRING".isupper(), "СТРОКА".isupper(), "".isupper()
# (True, True, False)
"STRING1".isupper(), "СТРОКА, 123".isupper(), "123".isupper()
# (True, True, False)
"string".isupper(), "STRing".isupper()
# (False, False)

# istitle() - возвращает True, если строка содержит буквы, и первые буквы всех слов
#             являются заглавными, в противном случае- False.
# Помимо букв строка может иметь другие символы, например цифры. Примеры:
"Str Str".istitle(), "Стр Cтp".istitle()
# (True, True)
"Str Str 123".istitle(), "Стр Стр 123".istitle()
# (True, True)
"Str str".istitle(), "Стр cтp".istitle()
# (False, False)
"".istitle(), "123".istitle()
# ( False, False)

# Переделаем программу суммирования произволыюго количества
# целых чисел, введенных пользователем, таким образом, чтобы при вводе строки вместо
# числа программа не завершалась с фатальной ошибкой. Кроме того, предусмотрим
# возможность ввода отрицательных целых чисел.

# Суммирование неопределенного количества чисел
# -*- coding: utf-8 -*-
print("Введите слово 'stop' для nолучения результата")
summa = 0
while True:
    x = input("Введите число: ")
    x = x.rstrip("\r")              # Для версии 3.2.0 (см. разд. 1.7)
    if x == "stop":
        break                       # Выход из цикла
    if x == "":
        print("Вы не ввели значение!")
        continue
    if x[0] == "-":                 # Если nервым символом является минус
        if not x[1:].isdigit():     # Если фрагмент не состоит из цифр
            print("Необходимо ввести число, а не строку'")
            continue
    else:                           # Если минуса нет, то проверяем всю строку
        if not x.isdigit():         # Если строка не состоит из цифр
            print ("Необходимо ввести число, а не строку!")
            continue
    x = int(x)                      # Преобразуем строку в число
    summa += x
print("Cyммa чисел равна:", summa)
input()

# Процесс ввода значений и получения результата выглядит так:

# Введите слово 'stop' для получения результата
# Введите число: 10
# Введите число:
# Вы не ввели значение'
# Введите число: str
# Необходимо ввести число, а не строку'
# Введите число: -5
# Введите число: -str
# Необходимо ввести число, а не строку'
# Введите число: stop
# Сумма чисел равна: 5


# ============================ Тип данных bytes ==================================

# Тип данных str отлично подходит для хранения текстовой информации, но что делать, если
# необходимо обрабатывать изображение? Ведь изображение не имеет кодировки, а значит,
# оно не может быть преобразовано в Unicode-cтpoкy. Для решения этой проблемы в Python 3
# были введены тиnы bytes и bytearray, которые позволяют хранить последовательность целых
# чисел в диапазоне от о до 255. Каждое такое число обозначает код символа.
# Тип данных bytes относится к неизменяемым типам, как и строки,
# а тип данных bytearray - к изменяемым, как и списки.

# Создать объект типа bytes можно следующими способами:

# - с помощью функции bytes([<Строка>, <Кодировка>[, <Обработка ошибок>]]).
#   Если параметры не указаны, то возвращается пустой объект.
#   Чтобы преобразовать строку в объект тиnа bytes, необходимо передать минимум два первых параметра.
#   Если строка указана только в первом параметре, то возбуждается исключение TypeError. Пример:
bytes()
# b''
bytes("строка", "cp1251")
# b'\xf1\xf2\xf0\xee\xea\xe0'

#bytes("строка")
#Traceback (most recent call last):
#  File "<pyshell#311>", line 1, in <module>
#    bytes("строка")
#TypeError: string argument without an encoding

# В третьем параметре могут быть указаны значения:
#   "strict" (при ошибке возбуждается исключение UnicodeEncodeError; знaчeниe пo умолчанию),
#   "replace" (неизвестный символ заменяется символом вопроса)
#   "ignore" (неизвестные символы игнорируются). Пример:

#bytes( "string\uFFFD", "cp1251", "strict")
#Traceback (most recent call last):
#  File "<pyshell#314>", line 1, in <module>
#    bytes( "string\uFFFD", "cp1251", "strict")
#  File "E:\Python34\lib\encodings\cp1251.py", line 12, in encode
#    return codecs.charmap_encode(input,errors,encoding_table)
#UnicodeEncodeError: 'charmap' codec can't encode character '\ufffd' in position 6: character maps to <undefined>

bytes("string\uFFFD", "cp1251", "replace")
# b'string?'
bytes("string\uFFFD", "cp1251", "ignore")
# b'string'

# - с помощью метода строк encode([encoding="utf-8"][, errors="strict"]).
#   Если кодировка не указана, то строка преобразуется в последовательность байтов в кодировке UTF-8.
#   В параметре errors могут быть указаны значения:
#   "strict" (значение no умолчанию),
#   "replace",
#   "ignore",
#   "xmlcharrefreplace" или
#   "backslashreplace". Пример:
"строка".encode()
# b'\xd1\x81\xd1\x82\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0'
"строка".encode(encoding="cp1251")
# b'\xf1\xf2\xf0\xee\xea\xe0'
"строка\uFFFD".encode(encoding="cp1251", errors="xmlcharrefreplace")
# b'\xf1\xf2\xf0\xee\xea\xe0&#65533;'
"строка\uFFFD".encode(encoding="cp1251", errors="backslashreplace")
# b'\xf1\xf2\xf0\xee\xea\xe0\\ufffd'


# - указав букву b (регистр не имеет значения) перед строкой в апострофах, кавычках, тройных
#   апострофах или тройных кавычках. Обратите внимание на то, что в строке могут
#   быть только символы с кодами, входящими в кодировку ASCI. Все остальные символы
#   должны быть представлены специальными последовательностями:
b"string", b'string', b"""string""", b'''string'''
# (b'string', b'string', b'string', b'string')

# b"строка"
# SyntaxError: bytes can only contain ASCII literal characters.

b"\xf1\xf2\xf0\xee\xea\xe0"
# b'\xf1\xf2\xf0\xee\xea\xe0'

# - с помощью функции bytes(<Последовательность>), которая преобразует последовательность
#   целых чисел от о до 255 в объект типа bytes. Если число не попадает в диапазон,
#   то возбуждается исключение Va1ueError. Пример:
b = bytes([225, 226, 224, 174, 170, 160])
b
# b'\xe1\xe2\xe0\xae\xaa\xa0'
str(b, "cp866")
# 'строка'

# - с помощью функции bytes(<Число>), которая задает количество элементов в последовательности
#   Каждый элемент будет содержать нулевой символ:
bytes(10)
# b'\х00\х00\х00\х00\х00\х00\х00\х00\х00\х00'

# - с помощью метода bytes.fromhex(<Строка>). Строка в этом случае должна содержать
#   шестнадцатеричные значения символов:
b = bytes.fromhex(" e1 e2e0ae aaa0 ")
b
# b'\xe1\xe2\xe0\xae\xaa\xa0'
str(b, "cp866")
# 'строка'
'''
Объекты типа bytes относятся к последовательностям. Каждый элемент такой последовательности
может хранить целое число от о до 255, которое обозначает код символа. Как и
все последовательности, объекты поддерживают обращение к элементу по индексу, получение
среза, конкатенацию, повторение и проверку на вхождение:
'''
b = bytes("string", "cp1251")
b
# b'string'
b[0]                        # обращение к элементу по индексу
# 115
b[1:3]                      # Получение среза
# b'tr'
b + b"123"                  # Конкатенация
# b'string123'
b * 3                       # Повторение
# b'stringstringstring'
115 in b, b"tr" in b, b"as" in b
# (True, True, False)
'''
Как видно из примера, при выводе объекта целиком, а также при извлечении среза производится
попытка отображения символов. Однако доступ по индексу возвращает целое число, а не символ.
Если преобразовать объект в список, то мы получим последовательность целых чисел:
'''
list(bytes("string", "cp1251"))
# [115, 116, 114, 105, 110, 103]

# Тип bytes относится к неизменяемым типам. Это означает, что можно получить значение
# по индексу, но изменить его нельзя:
b = bytes("string", "cp1251")
#b[0] = 168
#Traceback (most recent call last):
#  File "<pyshell#341>", line 1, in <module>
#    b[0] = 168
#TypeError: 'bytes' object does not support item assignment

# Объекты типа bytes поддерживают большинство строковых методов.
# Однако некоторые из этих методов могут некорректно работать с русскими буквами,
# Так в объектах типа bytes не удаётся изменить регистр символов.
# В этих случаях следует использовать тип str, а не тип bytes.
# Не поддерживаются строковые методы encode(), isidentifier(), isprintable(), isnumeric(),
# isdecimal(), format_map() и format(), а также операция форматирования.
# При использовании методов следует учитывать, что в параметрах
# нужно указывать объекты типа bytes, а не строки:
b = bytes("string", "cp1251")
b.replace(b"s", b"S")
# b'String'

# Необходимо также помнить, что смешивать строки и объекты типа bytes в выражениях нельзя.
# Предварительно необходимо явно преобразовать объекты к одному типу, а лишь
# затем производить операцию:
#b"string" + "string"
#Traceback (most recent call last):
#  File "<pyshell#345>", line 1, in <module>
#    b"string" + "string"
#TypeError: can't concat bytes to str

b"string" + "string".encode("ascii")
# b'stringstring'

# Объект типа bytes может содержать как однобайтовые символы, так и многобайтовые.
# При использовании многобайтовых символов некоторые функции могут работать не так,
# как ожидается, например, функция len() вернет количество байтов, а не символов:
len("строка")
# 6
len(bytes("строка", "cp1251"))
# 6
len(bytes("строка", "utf-8"))
# 12

# Преобразовать объект типа bytes в строку позволяет метод decode().
# Метод имеет следующий формат:

# decode([encoding="utf-8"][, errors="strict"])

# Параметр encoding задает кодировку символов (по умолчанию UTF-8) в объекте bytes, а
# параметр errors - способ обработки ошибок при преобразовании. В параметре errors
# можно указать значения "strict" (значение по умолчанию), "replace" или "ignore".
# Пример преобразования:
b = bytes("строка", "cp1251")
b.decode(encoding="cp1251"), b.decode("cp1251")
# ('строка', 'строка')

# Для преобразования можно также воспользоваться функцией str():
b = bytes("строка", "cp1251")
str(b, "cp1251")
# 'строка'

# Чтобы изменить кодировку данных, следует сначала преобразовать тиn bytes в строку, а
# затем произвести обратное преобразование, указав нужную кодировку.
# Преобразуем данные из кодировки Windows-1251 в кодировку KOI8-R, а затем обратно:
w = bytes("Строка", "cp1251")       #Данные в кодировке windows-1251
k = w.decode("cp1251").encode("koi8-r")
k, str(k, "koi8-r")                 # Данные в кодировке KOIB-R
# (b'\xf3\xd4\xd2\xcf\xcb\xc1', 'Строка')
w = k.decode("koi8-r").encode("cp1251")
w, str(w, "cp1251")                 # Данные в кодировке windows-1251
# (b'\xd1\xf2\xf0\xee\xea\xe0', 'Строка')


# =============================== Тип данных bytearray =====================================

# Тип данных bytearray является разновидностью типа bytes и поддерживает те же самые
# методы и операции. В отличие от типа bytes, тип bytearray допускает возможность непосредственного
# изменения объекта и содержит дополнительные методы, позволяющие выполнять эти изменения.
# Создать объект типа bytearray можно следующими способами:

# - с помощью функции bytearray([<Строка>, <Кодировка>[, <Обработка ошибок>]]).
#   Если параметры не указаны, то возвращается пустой объект. Чтобы преобразовать строку в
#   объект типа bytearray, необходимо передать минимум два первых параметра.
#   Если строка указана только в первом параметре, то возбуждается исключение TypeError. 
# Пример:
bytearray()
# bytearray(b'')
bytearray("строка", "cp1251")
# bytearray(b'\xf1\xf2\xf0\xee\xea\xe0')

#bytearray("строка")
#Traceback (most recent call last):
#  File "<pyshell#366>", line 1, in <module>
#    bytearray("строка")
#TypeError: string argument without an encoding

# В третьем параметре могут быть указаны значения:
#   "strict" (при ошибке возбуждается исключение UnicodeEncodeError; значение пo умолчанию),
#   "replace" (неизвестный символ заменяется символом вопроса) или
#   "ignore" (неизвестные символы игнорируются).

# Пример:
#bytearray("string\uFFFD", "cp1251", "strict")
#Traceback (most recent call last):
#  File "<pyshell#367>", line 1, in <module>
#    bytearray("string\uFFFD", "cp1251", "strict")
#  File "E:\Python34\lib\encodings\cp1251.py", line 12, in encode
#    return codecs.charmap_encode(input,errors,encoding_table)
#UnicodeEncodeError: 'charmap' codec can't encode character '\ufffd' in position 6: character maps to <undefined>

bytearray("string\uFFFD", "cp1251", "replace")
# bytearray(b'string?')
bytearray("string\uFFFD", "cp1251", "ignore")
# bytearray(b'string')

# - с помощью функции bytearray(<Последовательность>), которая преобразует последовательность
#   целых чисел от 0 до 255 в объект типа bytearray. Если число не попадает в диапазон, то
#   возбуждается исключение Va1ueError. Пример:
b = bytearray([225, 226, 224, 174, 170, 160])
b
# bytearray(b'\xe1\xe2\xe0\xae\xaa\xa0')
bytearray(b'\xe1\xe2\xe0\xae\xaa\xa0')
# bytearray(b'\xe1\xe2\xe0\xae\xaa\xa0')
str(b, "cp866")
# 'строка'

# - с помощью функции bytearray(<Число>), которая задает количество элементов в последовательности.
#   Каждый элемент будет содержать нулевой символ:
bytearray(5)
# bytearray(b'\x00\x00\x00\x00\x00')

# - с помощью метода bytearray.fromhex(<Строка>). Строка в этом случае должна содержать
#   шестнадцатеричные значения символов:
b = bytearray.fromhex(" e1 e2e0ae aaa0 ")
b
# bytearray(b'\xe1\xe2\xe0\xae\xaa\xa0')
str(b, "cp866")
# 'строка'

# Тип bytearray относится к изменяемым типам. Поэтому можно не только получить значение
# по индексу, но и изменить его (что не свойственно строкам):
b = bytearray("Python", "ascii")
b
# bytearray(b'Python')
b[0]                    # Получаем значение по индексу
# 80
b[0] = b"J"[0]          # Изменяем значение по индексу
b
# bytearray(b'Jython')

# При изменении значения важно помнить, что присваиваемое значение должно быть целым
# числом в диапазоне от 0 до 255. Чтобы получить число в предыдущем примере, мы создали
# объект типа bytes, а затем присвоили значение, расположенное по индексу 0 (b[0] = b"J"[O]).
# Можно, конечно было и сразу указать код символа:
b[0] = 75
b
# bytearray(b'Kython')

# Для изменения объекта можно также использовать следующие методы:
# - append(<Число>) - добавляет один элемент в конец объекта.
#   Метод изменяет текущий объект и ничего не возвращает. Пример:
b = bytearray("string", "ascii")
b.append(b"l"[0]); b
# bytearray(b'stringl')

# - extend(<Последовательность>) - добавляет элементы последовательности в конец объекта.
#   Метод изменяет текущий объект и ничего не возвращает. Пример:
b = bytearray("string", "ascii")
b.extend(b"l23"); b
# bytearray(b'stringl23')

# Добавить несколько элементов можно с помощью операторов + и +=:
b = bytearray("string", "ascii")
b + b"l23"              # Возвращает новый объект
# bytearray(b'stringl23')
b += b"456"; b          # Изменяет текущий объект
# bytearray(b'string456')

# Кроме того, можно воспользоваться операцией присваивания значения срезу:
b = bytearray("string", "ascii")
b[len(b):] = b"l23"     # Изменяет текущий список:
b
# bytearray(b'stringl23')
b = bytearray("string", "ascii")
b[2:2] = b"l23"; b
# bytearray(b'stl23ring')
b[1:3] = b"***"; b
# bytearray(b's***23ring')
b[0:3] = b"+++"; b
# bytearray(b'+++*23ring')
b[2:2] = b"---"; b
# bytearray(b'++---+*23ring')

# - insert(<Индекс>, <Число>) - добавляет один элемент в указанную позицию. Остальные
#   элементы смещаются. Метод изменяет текущий объект и ничего не возвращает. Добавим
#   элемент в начало объекта:
b = bytearray("string", "ascii")
b.insert(0, b"l"[0]); b
# bytearray(b'lstring')
# Метод insert() позволяет добавить только один элемент. Чтобы добавить несколько
# элементов, можно воспользоваться операцией присваивания значения срезу. Добавим
# несколько элементов в начало объекта:
b = bytearray("string", "ascii")
b[:0] = b"l23"; b
# bytearray(b'l23string')

# - pop([<Индекс>]) - удаляет элемент, расположенный по указанному индексу, и возвращает
#   его. Если индекс не указан, то удаляет и возвращает последний элемент. Примеры:
b = bytearray("string", "ascii")
b.pop()                 # Удаляем последний элемент
# 103
b
# bytearray(b'strin')
b.pop(0)                # Удаляем первый элемент
# 115
b
# bytearray(b'trin')

# Удалить элемент списка позволяет также оператор del:
b = bytearray("string", "ascii")
del b[5]; b             # Удаляем последний элемент
# bytearray(b'strin')
del b[:2]; b            # Удаляем первый и второй элементы
# bytearray(b'rin')

# - remove(<Число>) - удаляет первый элемент, содержащий указанное значение. Если
#   элемент не найден, возбуждается исключение ValueError. Метод изменяет текущий объект
#   и ничего не возвращает. Пример:
b = bytearray("strstr", "ascii")
b.remove(b"s"[0]); b    #Удаляет только первый элемент
# bytearray(b'trstr')

# - reverse() - изменяет порядок следования элементов на противоположный.
#   Метод изменяет текущий объект и ничего не возвращает. Пример:
b = bytearray("string", "ascii")
b.reverse(); b
# bytearray(b'gnirts')

# Преобразовать объект типа bytearray в строку позволяет метод decode().
# Метод имеет следующий формат:

# decode([encoding="utf-8"][, errors="strict"])

# Параметр encoding задает кодировку символов (по умолчанию UTF-8) в объекте bytearray,
# а параметр errors - способ обработки ошибок при преобразовании. В параметре errors
# можно указать значения "strict" (значение по умолчанию), "replace" или "ignore".
# Пример преобразования:
b = bytearray("строка", "cp1251")
b.decode(encoding="cp1251"), b.decode("cp1251")
# ('строка', 'строка')
# Для преобразования можно также воспользоваться функцией str():
b = bytearray("строка", "cp1251")
str(b, "cp1251")
# 'строка'


# ============================ Преобразование объекта в последовательность байтов ===================

# Преобразовать объект в последовательность байтов, а затем восстановить объект позволяет
# модуль pickle. Прежде чем использовать функции из этого модуля, необходимо подключить
# модуль с помощью инструкции:
import pickle
# Для преобразования предназначены две функции:
# - dumps(<Объект>[, <Протокол>][, fix_imports=True]) - производит сериализацию объекта
#   и возвращает последовательность байтов специального формата.
#   Формат зависит от указанного протокола (число от 0 до 3). Пример преобразования списка и кортежа:
import pickle
obj1 = [1, 2, 3, 4, 5]          # Список
obj2 = (6, 7, 8, 9, 10)         # Кортеж
pickle.dumps(obj1)
# b'\x80\x03]q\x00(K\x01K\x02K\x03K\x04K\x05e.'
pickle.dumps(obj2)
# b'\x80\x03(K\x06K\x07K\x08K\tK\ntq\x00.'

# - loads(<Последовательность байтов>[, fix _imports=True][, encoding="ASCII"][, errors="strict"]) -
#   преобразует последовательность байтов сnециального формата обратно в объект. Пример восстановления списка и кортежа:
pickle.loads(b'\x80\x03]q\x00(K\x01K\x02K\x03K\x04K\x05e. ')
# [1, 2, 3, 4, 5]
pickle.loads(b'\x80\x03(K\x06K\x07K\x08K\tK\ntq\x00. ')
# (6, 7, 8, 9, 10)


# ===================================== Шифрование строк ===========================================

# Для шифрования строк предназначен модуль hashlib. Прежде чем исnользовать функции из
# этого модуля, необходимо подключить модуль с помощью инструкции:
import hashlib
# Модуль предоставляет следующие функции: md5(), sha1(), sha224(), sha256(), sha384() и sha512().
# В качестве необязательного параметра функциям можно передать шифруемую последовательность байтов. Пример:
import hashlib
h = hashlib.sha1(b"password")
h
# <sha1 HASH object @ 0x02334CC8>

# Передать последовательность байтов можно также с помощью метода update(). В этом
# случае объект присоединяется к предыдущему значению:
h = hashlib.sha1()
h.update(b"password")

# Получить зашифрованную последовательность байтов и строку позволяют два метода -
# gest() и hexdigest():
h = hashlib.sha1(b"password")
h.digest()
# b'[\xaaa\xe4\xc9\xb9??\x06\x82%\x0bl\xf83\x1b~\xe6\x8f\xd8'
h.hexdigest()
# '5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8'

# Наиболее часто применяемой функцией является функция md5(), которая шифрует строку
# с помощью алгоритма MD5. Она используется для шифрования паролей, т. к. не существует
# алгоритма для дешифровки. Для сравнения введенного пользователем пароля с сохраненным
# в базе необходимо зашифровать введенный пароль, а затем произвести сравнение 

# Проверка правильнести ввода пapoля
import hashlib
h = hashlib.md5(b"password")
p = h.hexdigest()
p                               # Пароль, сохраненный в базе
# '5f4dcc3b5aa765d61d8327deb882cf99'
h2 = hashlib.md5(b"password")   # Пароль, введенный nользователем
if p == h2.hexdigest(): print("Пароль nравильный")

# Пароль правильный
